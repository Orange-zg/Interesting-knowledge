# Interesting-knowledge
##工作中遇到的有趣的知识点
* 为什么有时候直接打开html文件会报跨域的错（file 协议导致的跨域问题以及解决方案
   * 问题根源：同源策略 
   * 同源策略（Same origin policy），是出于安全而诞生的一种约定，规定了只能在本域内进行资源访问。所谓同源是指”协议+域名+端口”三者相同
   * 不同源之间进行资源访问，就需要跨域。特殊地，有三个标签默认是允许跨域加载资源的,即img的src、link的href、script的src
   * ES6 使用模块的时候要在标签中声明 type="module"，而这类使用了模块的 script 是受限于同源策略的。
   * 打开开发者工具，查看网络请求，Sec-Fetch-Mode 都是 cors即受同源策略影响，no-cors不受同源策略影响
   * 在本地打开文件，使用的不是 http 协议，而是 file 协议，它根本就没有跨域请求需要的 origin（注意看上图，origin 是空的）。所以，这种情况就要报错了
* 为什么js堆栈会出现内存溢出
  * 内存溢出：当程序运行所需内存超过了计算机剩余的内存时，程序崩溃并抛出的错误
  * 内存泄漏：内存被占用且没有及时释放，内存泄漏越多，计算机剩余的内存就越小，此时越容易发生内存溢出
  * 垃圾回收机制：根据内存泄漏的定义，有些变量或数据不再被使用或不需要了，那么它就是垃圾变量或垃圾数据，如果其一直保存在内存中，最终可能会导致内存占用过多的情况。那么此时就需要对这些垃圾数据进行回收
  * 问题解决：
     * V8引擎对Node.js(和Chrome V8)中的内存限制大小。
     * 代码分析：内存泄漏出现情况(重要)
     * Nodejs内存 - 扩大容量
* 为什么flex布局中text-overflow:ellipsis失效
  *问题根源：一个flex item元素的原始大小是如何确定的？优先级为flex-basis > width > 内容宽度，但min-width 和 max-width会限制住原始大小。当min-width为默认时，宽度为被内容撑开时，省略号会被隐藏。
  * 问题解决
     * 设置min-width：0即可  
* 在函数中，在foreach中，为啥使用return 无法结束函数
  * 原理：
     * forEach的实现方式用代码表示出来可以写成如下的结构
     * const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  const rs = (function(item) {
    console.log(item);
    if (item > 2) return false;
  })(arr[i])
}
     * 使用return语句相当于在每个自执行函数中将返回值复制给rs，但是实际对整个函数并没有影响。而使用break语句报错是因为再JS的解释器中break语句是不可以出现在函数体内的。
  * 解决方案：加个局部变量，判断状态然后再操作
     